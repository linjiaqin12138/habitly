# 余额管理系统设计

## 1. 总体说明

### 1.1 余额分类
余额系统包含三种类型的余额：
1. **可退余额**: 充值后3天内可申请退款的金额
2. **冻结金额**: 超过3天的充值金额，只能通过打卡返现解冻
3. **返现金额**: 通过打卡任务从冻结金额中解冻的部分，可随时提现

### 1.2 余额变更规则
- **充值**: 金额直接进入可退余额
- **可退余额自动冻结**: 充值3天后，可退余额自动转为冻结金额
- **打卡返现**: 完成打卡任务后，从冻结金额中解冻指定金额到返现金额
- **提现限制**: 只能提现返现金额部分
- **退款限制**: 只能退还3天内的可退余额

## 2. 数据库设计

### 2.1 balances 表
用户余额表，记录用户的三种余额

| 字段 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| id | uuid | uuid_generate_v4() | 主键 |
| user_id | uuid | - | 用户ID（外键关联users表） |
| refundable_amount | numeric | 0 | 可退余额 |
| frozen_amount | numeric | 0 | 冻结金额 |
| cashback_amount | numeric | 0 | 返现金额 |
| created_at | timestamptz | now() | 创建时间 |
| updated_at | timestamptz | now() | 更新时间 |

### 2.2 transactions 表
交易记录表，记录所有余额变动

| 字段 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| id | uuid | uuid_generate_v4() | 主键 |
| user_id | uuid | - | 用户ID（外键关联users表） |
| amount | numeric | - | 交易金额 |
| type | text | - | 交易类型（charge充值/refund退款/withdrawal提现） |
| related_charge_id | uuid | null | 关联的充值交易ID，用于退款时关联原充值订单 |
| reference_id | text | - | 外部交易参考号（如支付系统的订单号，暂时为空） |
| status | text | 'pending' | 交易状态（pending处理中/succeeded成功/failed失败） |
| created_at | timestamptz | now() | 创建时间 |
| updated_at | timestamptz | now() | 更新时间 |

交易发起后，如果支付系统是异步的，就先进入pending状态，等支付系统回调告知结果后更新为success或failed.
这个表只有insert/update(更新状态)，没有删除。对于退款交易，需要设置related_charge_id关联到原充值交易。

### 2.3 业务逻辑说明

1. 触发器：balances_update_trigger
- 功能：更新balances表时自动更新updated_at时间
- 时机：BEFORE UPDATE

2. 触发器：transactions_update_trigger  
- 功能：更新交易记录时自动更新updated_at时间
- 时机：BEFORE UPDATE

3. 交易状态变更处理（service层）
- 功能：交易成功时更新对应的余额
- 时机：当交易状态变更为succeeded时
- 动作：
  - charge: 增加可退余额
  - refund: 减少可退余额
  - withdrawal: 减少返现金额

4. 余额冻结处理（定时任务）
- 功能：定时检查并冻结超过3天的可退余额
- 实现：通过edge function定时执行
- 动作：将超过3天的可退余额转移到冻结金额

## 3. 领域模型定义

```typescript
// 数据库表模型
interface BalanceTable {
  id: string;
  user_id: string;
  refundable_amount: number;
  frozen_amount: number;
  cashback_amount: number;
  created_at: string;
  updated_at: string;
}

interface TransactionTable {
  id: string;
  user_id: string;
  amount: number;
  type: 'charge' | 'refund' | 'withdrawal';
  related_charge_id: string | null;
  reference_id: string | null;
  status: 'pending' | 'succeeded' | 'failed';
  created_at: string;
  updated_at: string;
}

// 领域模型
interface Balance {
  id: string;
  userId: string;
  refundableAmount: number;
  frozenAmount: number;
  cashbackAmount: number;
  createdAt: Date;
  updatedAt: Date;
}

interface Transaction {
  id: string;
  userId: string;
  amount: number;
  type: 'charge' | 'refund' | 'withdrawal';
  relatedChargeId: string | null;
  referenceId: string | null;
  status: 'pending' | 'succeeded' | 'failed';
  createdAt: Date;
  updatedAt: Date;
}

// API请求/响应类型
interface CreateTransactionRequest {
  amount: number;
  type: 'charge' | 'refund' | 'withdrawal';
  relatedChargeId?: string; // 退款时需要提供
}

interface UpdateTransactionStatusRequest {
  status: 'succeeded' | 'failed';
  referenceId?: string;
}

interface BalanceResponse {
  refundableAmount: number;
  frozenAmount: number;
  cashbackAmount: number;
}
```

## 4. API 接口设计

所有接口通过Supabase客户端访问，基于Row Level Security确保安全。

### 4.1 余额查询

```typescript
// 获取用户余额
const getBalance = async (userId: string): Promise<BalanceResponse> => {
  const { data, error } = await supabase
    .from('balances')
    .select('*')
    .eq('user_id', userId)
    .single();
    
  if (error) throw error;
  return {
    refundableAmount: data.refundable_amount,
    frozenAmount: data.frozen_amount,
    cashbackAmount: data.cashback_amount
  };
};
```

### 4.2 交易相关

```typescript
// 创建充值交易
const createChargeTransaction = async (
  userId: string, 
  amount: number
): Promise<Transaction> => {
  const { data, error } = await supabase
    .from('transactions')
    .insert({
      user_id: userId,
      amount,
      type: 'charge',
      status: 'pending'
    })
    .select()
    .single();
    
  if (error) throw error;
  return data;
};

// 创建退款交易（需检查可退余额是否足够）
const createRefundTransaction = async (
  userId: string,
  amount: number,
  relatedChargeId: string
): Promise<Transaction> => {
  // 1. 检查可退余额
  const balance = await getBalance(userId);
  if (balance.refundableAmount < amount) {
    throw new Error('Insufficient refundable balance');
  }

  // 2. 创建退款交易
  const { data, error } = await supabase
    .from('transactions')
    .insert({
      user_id: userId,
      amount: -amount, // 使用负数表示退款
      type: 'refund',
      status: 'pending',
      related_charge_id: relatedChargeId
    })
    .select()
    .single();
    
  if (error) throw error;
  return data;
};

// 创建提现交易（需检查返现余额是否足够）
const createWithdrawalTransaction = async (
  userId: string,
  amount: number
): Promise<Transaction> => {
  // 1. 检查返现余额
  const balance = await getBalance(userId);
  if (balance.cashbackAmount < amount) {
    throw new Error('Insufficient cashback balance');
  }

  // 2. 创建提现交易
  const { data, error } = await supabase
    .from('transactions')
    .insert({
      user_id: userId,
      amount: -amount, // 使用负数表示提现
      type: 'withdrawal',
      status: 'pending'
    })
    .select()
    .single();
    
  if (error) throw error;
  return data;
};

// 获取用户交易历史
const getTransactions = async (
  userId: string, 
  options: { page: number; limit: number }
): Promise<Transaction[]> => {
  const { data, error } = await supabase
    .from('transactions')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false })
    .range(
      options.page * options.limit,
      (options.page + 1) * options.limit - 1
    );
    
  if (error) throw error;
  return data;
};
```

### 4.3 余额更新

```typescript
// 更新用户余额（仅在服务端使用）
const updateBalance = async (
  userId: string,
  updates: {
    refundableAmount?: number;
    frozenAmount?: number;
    cashbackAmount?: number;
  }
): Promise<Balance> => {
  const { data, error } = await supabase
    .from('balances')
    .update({
      refundable_amount: updates.refundableAmount,
      frozen_amount: updates.frozenAmount,
      cashback_amount: updates.cashbackAmount,
    })
    .eq('user_id', userId)
    .select()
    .single();

  if (error) throw error;
  return data;
};

// 处理充值成功
const handleChargeSuccess = async (userId: string, transactionId: string, amount: number) => {
  const { error } = await supabase.rpc('handle_charge_success', {
    p_user_id: userId,
    p_transaction_id: transactionId,
    p_amount: amount
  });
  
  if (error) throw error;
};

// 处理退款成功
const handleRefundSuccess = async (userId: string, transactionId: string, amount: number) => {
  const { error } = await supabase.rpc('handle_refund_success', {
    p_user_id: userId,
    p_transaction_id: transactionId,
    p_amount: amount
  });
  
  if (error) throw error;
};

// 处理提现成功
const handleWithdrawSuccess = async (userId: string, transactionId: string, amount: number) => {
  const { error } = await supabase.rpc('handle_withdraw_success', {
    p_user_id: userId,
    p_transaction_id: transactionId,
    p_amount: amount
  });
  
  if (error) throw error;
};
```

### 4.4 交易状态更新

```typescript
// 更新交易状态
const updateTransactionStatus = async (
  transactionId: string,
  request: UpdateTransactionStatusRequest
): Promise<Transaction> => {
  // 1. 开始数据库事务
  const { data: transaction, error: selectError } = await supabase
    .from('transactions')
    .select()
    .eq('id', transactionId)
    .single();

  if (selectError) throw selectError;
  if (!transaction) throw new Error('Transaction not found');

  // 2. 更新交易状态
  const { data, error: updateError } = await supabase
    .from('transactions')
    .update({ 
      status: request.status,
      reference_id: request.referenceId,
    })
    .eq('id', transactionId)
    .select()
    .single();

  if (updateError) throw updateError;

  // 3. 如果交易成功，更新余额
  if (request.status === 'succeeded') {
    switch (transaction.type) {
      case 'charge':
        await handleChargeSuccess(transaction.user_id, transactionId, transaction.amount);
        break;
      case 'refund':
        await handleRefundSuccess(transaction.user_id, transactionId, -transaction.amount);
        break;
      case 'withdrawal':
        await handleWithdrawSuccess(transaction.user_id, transactionId, -transaction.amount);
        break;
    }
  }

  return data;
};

// 定时任务：将过期的可退余额转移到冻结余额
const freezeExpiredRefundableBalance = async () => {
  const { error } = await supabase.rpc('freeze_expired_refundable_balance');
  if (error) throw error;
};
```

### 4.5 数据库存储过程

```sql
-- 处理充值成功
CREATE OR REPLACE FUNCTION public.handle_charge_success(
  p_user_id uuid,
  p_transaction_id uuid,
  p_amount numeric
) RETURNS void AS $$
BEGIN
  -- 更新余额
  UPDATE public.balances
  SET refundable_amount = refundable_amount + p_amount
  WHERE user_id = p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 处理退款成功
CREATE OR REPLACE FUNCTION public.handle_refund_success(
  p_user_id uuid,
  p_transaction_id uuid,
  p_amount numeric
) RETURNS void AS $$
BEGIN
  -- 更新余额
  UPDATE public.balances
  SET refundable_amount = refundable_amount - p_amount
  WHERE user_id = p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 处理提现成功
CREATE OR REPLACE FUNCTION public.handle_withdraw_success(
  p_user_id uuid,
  p_transaction_id uuid,
  p_amount numeric
) RETURNS void AS $$
BEGIN
  -- 更新余额
  UPDATE public.balances
  SET cashback_amount = cashback_amount - p_amount
  WHERE user_id = p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 定时任务：冻结过期可退余额
CREATE OR REPLACE FUNCTION public.freeze_expired_refundable_balance()
RETURNS void AS $$
BEGIN
  -- 找出超过3天的充值交易
  WITH expired_charges AS (
    SELECT 
      t.user_id,
      t.amount
    FROM transactions t
    WHERE 
      t.type = 'charge' 
      AND t.status = 'succeeded'
      AND t.created_at < NOW() - INTERVAL '3 days'
      -- 排除已退款的充值
      AND NOT EXISTS (
        SELECT 1 
        FROM transactions r 
        WHERE r.related_charge_id = t.id 
          AND r.type = 'refund' 
          AND r.status = 'succeeded'
      )
  )
  -- 更新余额
  UPDATE balances b
  SET 
    refundable_amount = b.refundable_amount - ec.amount,
    frozen_amount = b.frozen_amount + ec.amount
  FROM expired_charges ec
  WHERE b.user_id = ec.user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## 5. RLS 权限策略

设置适当的行级安全策略以保护数据：

```sql
-- balances表的RLS策略
ALTER TABLE public.balances ENABLE ROW LEVEL SECURITY;

-- 用户只能查看自己的余额
CREATE POLICY "Users can view own balance"
ON public.balances FOR SELECT
USING (auth.uid() = user_id);

-- transactions表的RLS策略
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;

-- 用户可以查看自己的交易记录
CREATE POLICY "Users can view own transactions"
ON public.transactions FOR SELECT
USING (auth.uid() = user_id);

-- 用户可以创建交易（但状态必须是pending）
CREATE POLICY "Users can create pending transactions"
ON public.transactions FOR INSERT
WITH CHECK (
  auth.uid() = user_id 
  AND status = 'pending'
  AND type IN ('charge', 'refund', 'withdrawal')
);
```

## 6. 实现注意事项

1. 安全性
   - 所有金额相关的计算必须在数据库触发器中进行
   - 客户端只能创建pending状态的交易
   - 余额更新必须通过服务端实现，不允许用户修改

2. 一致性
   - 使用事务确保余额和交易记录的一致性
   - 定时任务处理超时的pending交易

3. 并发处理
   - 使用数据库行锁防止余额更新的并发问题
   - 交易处理要考虑幂等性

4. 后续优化
   - 添加实际支付系统集成
   - 完善交易通知机制
   - 添加交易流水号和备注字段